# 1，**ORM**，(Object relationship Mapping)，对象关系映射

- 类和表结构对应
- 属性和字段对应
- 对象和记录对应

# 2，Java动态性之：反射机制 reflection

。反射机制

。动态编译

。动态执行javascript代码

。动态字节码操作

**一个类被加载后，JVM会创建一个对应该类的Class对象，类的整个结构信息会放到对应的Class对象中，这个Class对象就像一面镜子一样，通过这面镜子我可以看到对应类的全部信息**

# 3，反射的基本操作

````java
	   String path = "Texts.bean.User";

        try {
            Class clazz = Class.forName(path);

            //获取包名 + 类的名字
            System.out.println(clazz.getName());

            //获取类的名字
            System.out.println(clazz.getSimpleName());

            //获取属性信息
            //该方法只能获取public的属性
            Field[] fields = clazz.getFields();
            System.out.println(fields.length);
            //该方法可以获取到所有的属性
            Field[] fields1 = clazz.getDeclaredFields();
            System.out.println(fields1.length);
            for (Field temp : fields1) {
                System.out.println("属性：" + temp);
            }

            //获取方法信息
            Method[] method = clazz.getDeclaredMethods();
            //获取指定的方法信息,可以指定方法的参数类型，防止方法重载无法取到想要的方法
            Method method1 = clazz.getDeclaredMethod("setAge",int.class);
            for (Method temp : method) {
                System.out.println("方法：" + temp);
            }

            //获得构造器信息
            Constructor[] constructors = clazz.getDeclaredConstructors();
            for (Constructor temp : constructors) {
                System.out.println("构造器：" + temp);
            }


        } catch (ClassNotFoundException | NoSuchMethodException e) {
            e.printStackTrace();
        }
````

# 4，通过反射，动态的操作构造器，方法和属性

````java
String path = "Texts.bean.User";

        try {
            Class<User> clazz = (Class<User>) Class.forName(path);

            //通过反射API调用了构造方法，构造对象，本质上是调用了User的无参构造方法
            User user = clazz.newInstance();
            System.out.println(user);

            //通过反射API调用了我们的带参构造器
            Constructor<User> c = clazz.getDeclaredConstructor(int.class,int.class,String.class);
            User user1 = c.newInstance(1001,20,"yth");
            System.out.println(user1.getName() + " " + user1.getAge() + " " + user1.getId());

            //通过反射API调用普通方法
            User user2 = clazz.newInstance();
            Method method = clazz.getDeclaredMethod("setName", String.class);
            method.invoke(user2,"ythmx");
            System.out.println(user2.getName());

            //通过反射API操作属性
            User user3 = clazz.newInstance();
            Field field = clazz.getDeclaredField("name");
            //表示这个属性不需要做安全检查，可以直接访问
            field.setAccessible(true);
            //通过反射直接写属性
            field.set(user3,"mx");
            //通过反射直接读属性的值
            System.out.println(field.get(user3));


        } catch (Exception e) {
            e.printStackTrace();
        }
````

# 5，Java可以通过**JavaCompiler**进行动态编译

第一个参数：为java编译器提供参数

第二个参数：得到java编译器的输出信息

第三个参数：接受编译器的错误信息

第四个参数：可变参数（是一个String数组）能传入一个或多个Java源文件

返回值：0表示编译成功，非0表示编译失败

# 6，脚本引擎的介绍：使得Java应用程序可以通过一套固定的接口与各种脚本引擎交互，从而达到在Java平台上调用各种脚本语言的目的。

````java
	    //获得脚本引擎对象
        ScriptEngineManager sem = new ScriptEngineManager();
        ScriptEngine engine = sem.getEngineByName("javascript");

        //定义变量，存储到引擎上下文中
        engine.put("msg","yth and mx");
        String str = "var user = {name:'yth',age:18,schools:['河北农业大学','sxt']};";
        str += "println(user.name);";

        //执行脚本
        engine.eval("msg = 'sxt is a good school';");
        System.out.println(engine.get("msg"));

		//定义函数
        engine.eval("function add(a,b) {var sum = a + b; return sum;}");
        //取得调用接口
        Invocable jsInvoke = (Invocable) engine;
        //执行脚本中定义的方法
        Object result1 = jsInvoke.invokeFunction("add",new Object[]{10,20});
        System.out.println(result1);
````

# 7，Java动态性的两种常见实现方式：字节码操作，反射。

运行时操作字节码，可以让我们实现如下功能，动态生成新的类，动态改变某个类的结构

# 8，利用Java操作字节码，生成一个类

````java
//先获取到类池对象
        ClassPool pool = ClassPool.getDefault();
        CtClass cc = pool.makeClass("Texts.Emp");

        //创建属性
        CtField f1 = CtField.make("private int empno;",cc);
        CtField f2 = CtField.make("private String name;",cc);
        cc.addField(f1);
        cc.addField(f2);

        //创建方法
        CtMethod m1 = CtMethod.make("public int getEmpno(){ return empno; }",cc);
        CtMethod m2 = CtMethod.make("public void setEmpno(int empno){ this.empno = empno; }",cc);
        cc.addMethod(m1);
        cc.addMethod(m2);

        //添加构造器
        CtConstructor ctConstructor = new CtConstructor(new CtClass[]{CtClass.intType,pool.get("java.lang.String")},cc);
        ctConstructor.setBody("{this.empno = empno; this.name = name;}");
        cc.addConstructor(ctConstructor);

        //将上面构造好的类写入到该路径中
        cc.writeFile("D:/Myjava");
        System.out.println("成功生成");
````

# 9，JVM核心，JVM运行和类加载的全过程

类加载的全过程，加载，链接，初始化。

**加载**，将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时的数据结构，在堆中生成一代表这个类的java.lang.Class对象。

**链接**，将Java类的二进制代码合并到JVM的运行状态之中的过程

。验证：确保加载的类信息符合JVM规范，没有安全方面的问题

。准备：正式为类变量(static变量)分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配

。解析：虚拟机常量池内的符号引用替换为直接引用的过程

**初始化**，初始化阶段是执行类构造器<clinit> ()方法的过程，类构造器<clinit> ()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static块)中的语句合并产生的。当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先出发其父类的初始化。虚拟机会保证一个类的<clinit> ()方法在多线程环境中被正确加锁和同步。当访问一个Java类的静态域时，只有真正声明这个域的类才会被初始化。

# 10，类的主动引用（一定会发生类的初始化），类的被动引用（不会发生类的初始化）

# 11，类加载器

父子级关系，从左到右，左边是右边的父类。引导类加载器、扩展类加载器、应用程序类加载器、自定义类加载器。

````java
		//获取当前的类加载器
        System.out.println(ClassLoader.getSystemClassLoader());
        //获取当前类加载器的父类
        System.out.println(ClassLoader.getSystemClassLoader().getParent());
        //获取当前类加载器的父类的父类
      System.out.println(ClassLoader.getSystemClassLoader().getParent().getParent());
````

# 12，类加载器的代理模式（交给其他加载器来加载指定的类）

**双亲委托机制**，他是代理模式的一种，目的是为了保证Java核心库的类型安全。

定义：某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次追溯，直到最高的爷爷辈，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。

# 13，**注意**，被两个类加载器加载的同一个类，JVM不认为是相同的类。

# 14，OSGI (Open Service Gateway Initative) 是面向Java的动态模块系统。它为开发人员提供了面向服务和基于组件的运行环境，并提供标准的方法用来管理软件的生命周期。

OSGI中的每个模块都有对应的一个类加载器。它负责加载模块自己包含的Java包和类。

